<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Flight log]]></title>
  <subtitle><![CDATA[About code, machine learning and part of Hugo's life.]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://hugofeng.info/"/>
  <updated>2014-05-06T23:22:01.769Z</updated>
  <id>http://hugofeng.info/</id>
  
  <author>
    <name><![CDATA[Hugo Feng]]></name>
    <email><![CDATA[hugo.fxy@gmail.com]]></email>
  </author>
  
  <generator uri="http://zespia.tw/hexo/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Floating point operations on ARM processor]]></title>
    <link href="http://hugofeng.info/2014/04/25/float-operations-on-arm/"/>
    <id>http://hugofeng.info/2014/04/25/float-operations-on-arm/</id>
    <published>2014-04-25T19:32:34.000Z</published>
    <updated>2014-05-06T23:15:42.000Z</updated>
    <content type="html"><![CDATA[<p>This article is a brief introduction of different implementations of floating point operation on an ARM processor.</p>
<h3 id="1-_Early_ages">1. Early ages</h3>
<p>There’s no coprocessor for floating point operations on ARM, those operations are done by CPU, means of which is called <code>Float Math Emulation</code>. Normally each float point operation costs thousands of cycles, which is very inefficient. </p>
<h3 id="2-_Soft-float">2. Soft-float</h3>
<p>This is for those situations where the CPU does not contain a <code>floating point unit(FPU)</code>, which is a built-in coprocessor on CPU to deal with floating point operations. </p>
<p>There are 2 different ways to do floating point operations without FPU: </p>
<ol>
<li><p>The kernel will trap all the opcodes related to the FPU and then perform the calculations itself [1]. This is called <code>NWFPE</code> (NetWinder Floating Point Emulator), however, this has now been removed from ARM kernel [2]. As I mentioned before, this is the old fashioned way of implementation, which involves raising of invalid instruction exceptions each time the situation occurs [3]. And this can be very expensive for computation. </p>
</li>
<li><p>All floating point operations are translated to specific inline function calls by compiler. This is done by passing flag <code>-mfloat-abi=soft</code> when using <code>gcc</code>, and gcc will use built in software(library) to emulate.</p>
</li>
</ol>
<h3 id="3-_Hard-float">3. Hard-float</h3>
<p>Nowadays, many chips has hardware <code>FPU</code> support to accelerate fp operations, for ARM familis, this unit is often called <code>VFP</code> (Vector Floating-Point coprocessor). VFP is a fully IEEE-754 compatible floating point unit. But later a much more powerful NEON Advanced SIMD unit was introduced and is suggested instead of VFP by Architecture Reference Manual.</p>
<a id="more"></a>

<h4 id="3-1_VFP">3.1 VFP</h4>
<p>One of the nice feature VFP provides is that it supports single and double-precision arithmetic on vector-vector, vector-scalar, and scalar-scalar data sets where vectors can consist of up to 8 single-precision, or 4 double-precision elements [4]. The “vector mode” instructions of VFP is actually sequential, so the speed up is very limited [8]. There’s one thing worth mentioning, that the “vector mode” of VFP is actually deprecated, replaced shortly after its introduce, with the much more powerful NEON Advanced SIMD unit [9]. </p>
<p>To use VFP, one need to pass flag <code>-mfloat-abi=softfp</code> or <code>-mfloat-abi=hard</code> to gcc when compiling.</p>
<h5 id="3-1-1_Difference_between_softfp_and_hard_mode">3.1.1 Difference between <code>softfp</code> and <code>hard</code> mode</h5>
<ul>
<li><p>For <code>softfp</code> mode:<br>Using general integer registers to pass values (like the <code>soft</code> mode). It also support linking to <code>soft</code> mode compiled binaris. </p>
</li>
<li><p>For <code>hard</code> mode:<br>Using floating point registers on FPU to pass values. Doesn’t support linking to <code>soft</code> mode binaris. All codes must be compiled in <code>hard</code> mode. It saves up to 20 cycles when calling a function with fp arguments, therefore faster than <code>softfp</code> mode [6].</p>
</li>
</ul>
<p>Nowadays, ARM Linux is set to <code>hard</code> mode by default [3] while Debian Armel set <code>softfp</code> as default [7]. And these two modes are not compatible in one application due to different value passing conventions. </p>
<p>Besides, <code>-msoft-float</code> equals to <code>-mfloat-abi=soft</code>, so as <code>-mhard-float</code> to <code>-mfloat-abi=hard</code> [8].</p>
<h4 id="3-2_New_era,_with_Neon">3.2 New era, with Neon</h4>
<p>The Advanced SIMD extension (aka NEON or “MPE” Media Processing Engine) is a combined 64- and 128-bit SIMD instruction set that provides standardized acceleration for media and signal processing applications. NEON is included in all Cortex-A8 devices but is optional in Cortex-A9 devices [9]. </p>
<p>Neon shares the same floating point registers with VFP, and thanks to floating point pipeline technology that Neon supports, it is a lot faster than VFP, but the draw back is that the NEON floating point pipeline is not entirely IEEE-754 compliant[10]. </p>
<p>Following is quoted from Peter on <a href="http://stackoverflow.com/questions/4097034/arm-cortex-a8-whats-the-difference-between-vfp-and-neon" target="_blank">StackOverflow</a>. He’s got a good introduction on this.</p>
<blockquote>
<p>Because it is not IEEE-754 compliant, a compiler cannot generate these instructions unless you tell the compiler that you are not interested in full compliance. This can be done in several ways.</p>
<ol>
<li><p>Using an intrinsic function to force NEON usage, for example see the <a href="http://gcc.gnu.org/onlinedocs/gcc/ARM-NEON-Intrinsics.html" target="_blank">GCC Neon Intrinsic Function List</a>.</p>
</li>
<li><p>Ask the compiler, very nicely. Even newer GCC versions with <code>-mfpu=neon</code> will not generate floating point NEON instructions unless you also specify <code>-funsafe-math-optimizations</code>.</p>
</li>
</ol>
</blockquote>
<h3 id="4-_Conclusion">4. Conclusion</h3>
<p>ARM chips is not specifically designed for floating point operations, but with the help of coprocessors, the speed of these expensive operations can be greatly improved.</p>
<h3 id="5-_Reference">5. Reference</h3>
<ul>
<li>[1] <a href="http://www.nslu2-linux.org/wiki/FAQ/SoftHardFloatCompiler" target="_blank">http://www.nslu2-linux.org/wiki/FAQ/SoftHardFloatCompiler</a></li>
<li>[2] <a href="http://lwn.net/Articles/546840/" target="_blank">http://lwn.net/Articles/546840/</a></li>
<li>[3] <a href="http://linux-7110.sourceforge.net/howtos/netbook_new/x1114.htm" target="_blank">http://linux-7110.sourceforge.net/howtos/netbook_new/x1114.htm</a></li>
<li>[4] <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0301h/Cegdejjh.html" target="_blank">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0301h/Cegdejjh.html</a></li>
<li>[5] <a href="http://www.gurucoding.com/en/rpi_cross_compiler/diff_hardfp_softfp.php" target="_blank">http://www.gurucoding.com/en/rpi_cross_compiler/diff_hardfp_softfp.php</a></li>
<li>[6] <a href="https://community.freescale.com/thread/219966" target="_blank">https://community.freescale.com/thread/219966</a></li>
<li>[7] <a href="https://wiki.debian.org/ArmEabiPort" target="_blank">https://wiki.debian.org/ArmEabiPort</a></li>
<li>[8] <a href="http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/ARM-Options.html#ARM-Options" target="_blank">http://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/ARM-Options.html#ARM-Options</a></li>
<li>[9] <a href="http://en.wikipedia.org/wiki/ARM_architecture" target="_blank">http://en.wikipedia.org/wiki/ARM_architecture</a></li>
<li>[10] <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204h/Bcfhfbga.html" target="_blank">http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0204h/Bcfhfbga.html</a></li>
</ul>
]]></content>
    <summary type="html"><![CDATA[<p>This article is a brief introduction of different implementations of floating point operation on an ARM processor.</p>
<h3 id="1-_Early_ages">1. Early ages</h3>
<p>There’s no coprocessor for floating point operations on ARM, those operations are done by CPU, means of which is called <code>Float Math Emulation</code>. Normally each float point operation costs thousands of cycles, which is very inefficient. </p>
<h3 id="2-_Soft-float">2. Soft-float</h3>
<p>This is for those situations where the CPU does not contain a <code>floating point unit(FPU)</code>, which is a built-in coprocessor on CPU to deal with floating point operations. </p>
<p>There are 2 different ways to do floating point operations without FPU: </p>
<ol>
<li><p>The kernel will trap all the opcodes related to the FPU and then perform the calculations itself [1]. This is called <code>NWFPE</code> (NetWinder Floating Point Emulator), however, this has now been removed from ARM kernel [2]. As I mentioned before, this is the old fashioned way of implementation, which involves raising of invalid instruction exceptions each time the situation occurs [3]. And this can be very expensive for computation. </p>
</li>
<li><p>All floating point operations are translated to specific inline function calls by compiler. This is done by passing flag <code>-mfloat-abi=soft</code> when using <code>gcc</code>, and gcc will use built in software(library) to emulate.</p>
</li>
</ol>
<h3 id="3-_Hard-float">3. Hard-float</h3>
<p>Nowadays, many chips has hardware <code>FPU</code> support to accelerate fp operations, for ARM familis, this unit is often called <code>VFP</code> (Vector Floating-Point coprocessor). VFP is a fully IEEE-754 compatible floating point unit. But later a much more powerful NEON Advanced SIMD unit was introduced and is suggested instead of VFP by Architecture Reference Manual.</p>
]]></summary>
    
      <category term="embedded" scheme="http://hugofeng.info/tags/embedded/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shell Script for Hexo source folder backup]]></title>
    <link href="http://hugofeng.info/2014/04/17/shell-script-for-hexo-source-folder-backup/"/>
    <id>http://hugofeng.info/2014/04/17/shell-script-for-hexo-source-folder-backup/</id>
    <published>2014-04-17T18:45:20.000Z</published>
    <updated>2014-04-21T21:36:04.000Z</updated>
    <content type="html"><![CDATA[<p><a href="http://hexo.io" target="_blank">Hexo</a> is a very good tool to generate blog pages from mardown files, and it is more comvinient together with Github. But everytime I deploy a new post to Github using <code>hexo deploy</code>, it only commits generated .html files to the repo. </p>
<p>Those original <code>.md</code> articles however seems very important to me for revising contents in the future, and it would be troublesome if those <code>.md</code> files were somehow lost. </p>
<p>In order to keep them save and track my every changes, I decide to find a way to put them altogether in the repo with the deployed .html files. So I wrote a shell script the achieve this.</p>
<a id="more"></a>

<p>In blog project folder:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ vim <span class="keyword">push</span><span class="preprocessor">.sh</span>
</pre></td></tr></table></figure>

<p>add content:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="shebang">#!/bin/bash
</span>
hexo generate
<span class="keyword">if</span> test <span class="operator">-d</span> public/<span class="built_in">source</span>_backup
<span class="keyword">then</span>
    rm -rf public/<span class="built_in">source</span>_backup
<span class="keyword">fi</span>
cp -r <span class="built_in">source</span>/ public/<span class="built_in">source</span>_backup
hexo deploy
</pre></td></tr></table></figure>


<p>add executable:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ <span class="keyword">chmod</span> +<span class="keyword">x</span> <span class="keyword">push</span>.sh
</pre></td></tr></table></figure>


<p>This script first generate “ready to publish” page files, and then check if previous version of source_backup directory exit. If exits, delete it and copy the latest version, then deploy it. <code>hexo deploy</code> command will automatically add everything in public/ folder and commit the changes.</p>
<p>Next time use this command to deploy:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre>$ ./<span class="keyword">push</span><span class="preprocessor">.sh</span>
</pre></td></tr></table></figure>


<p>Therefore, we have our original <code>.md</code> files safely tracked in GitHub, we can easily make changes to the posts on whatever version in the past you want. You can have the script copied to other directory if you have other Hexo projects, or add them to your <code>.bash_profile</code> script.</p>
]]></content>
    <summary type="html"><![CDATA[<p><a href="http://hexo.io" target="_blank">Hexo</a> is a very good tool to generate blog pages from mardown files, and it is more comvinient together with Github. But everytime I deploy a new post to Github using <code>hexo deploy</code>, it only commits generated .html files to the repo. </p>
<p>Those original <code>.md</code> articles however seems very important to me for revising contents in the future, and it would be troublesome if those <code>.md</code> files were somehow lost. </p>
<p>In order to keep them save and track my every changes, I decide to find a way to put them altogether in the repo with the deployed .html files. So I wrote a shell script the achieve this.</p>
]]></summary>
    
      <category term="hexo" scheme="http://hugofeng.info/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Compile OpenCV 3.0 on OSX]]></title>
    <link href="http://hugofeng.info/2014/04/17/Compile%20OpenCV3.0%20on%20OSX/"/>
    <id>http://hugofeng.info/2014/04/17/Compile OpenCV3.0 on OSX/</id>
    <published>2014-04-17T15:37:43.000Z</published>
    <updated>2014-05-06T23:16:06.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-_Install">1. Install</h3>
<p>Installing OpenCV on Mac can be fairly simple—using <code>homebrew</code>, however, <code>homebrew</code> can only install a stable version of it(currently 2.4.8.2). If you want to have a taste of OpenCV3.0, you’ll have to build from the source. This sometimes can be very annoying[1][2]. After more than a day’s struggle, I find a solution for my machine.</p>
<p>If you have anaconda installed, probably the vtk module has a version of 5.x, but OpenCV3.0 need vtk at least 6.1.[1]</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>brew install vtk   <span class="comment"># This gonna take some time</span>
</pre></td></tr></table></figure>


<p>Now download the latest OpenCV source:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>git clone git<span class="variable">@github</span>.<span class="symbol">com:</span><span class="constant">Itseez</span>/opencv.git
</pre></td></tr></table></figure>


<p>Go to OpenCV source folder, </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="variable">$ </span>mkdir build
<span class="variable">$ </span>cd build
<span class="variable">$ </span>cmake <span class="string">"Unix Makefile"</span> -<span class="constant">D</span> <span class="constant">CMAKE_OSX_ARCHITECTURES</span>=x86_64 -<span class="constant">D</span> <span class="constant">BUILD_PERF_TESTS</span>=<span class="constant">OFF</span> ..
</pre></td></tr></table></figure>


<p>Since OpenCV module ‘viz’ has to be compiled with libc++ instead of libstdc++, we need to make some changes to the makefiles to ensure it is compiled that way.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
2
</pre></td><td class="code"><pre><span class="variable">$ </span>cd modules/viz/<span class="constant">CMakeFiles</span>/opencv_viz.dir/
<span class="variable">$ </span>vim flags.make
</pre></td></tr></table></figure>


<p>Add flag <code>-std=c++11 -stdlib=libc++</code><br>Do the same to <code>build/modules/viz/CMakeFiles/opencv_test_viz.dir/flags.make</code><br>Now back to the build folder. </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>make -j8  <span class="comment"># Using 8 threads to build</span>
</pre></td></tr></table></figure>


<p>And it should work fine.<br>Now finish up:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$ </span>make install
</pre></td></tr></table></figure>


<h3 id="2-_Check">2. Check</h3>
<p>There’re generally 2 ways to check OpenCV’s version. </p>
<ol>
<li><p>In the OpenCV source folder, version number is defined in file:</p>
<pre><code> modules/core/<span class="built_in">include</span>/opencv2/core/<span class="built_in">version</span>.hpp 
</code></pre></li>
<li><p>After <code>make install</code>, you can see the copied libraries, they are usually named with version numbers. Like <code>libopencv_core.3.0.0.dylib</code>.</p>
</li>
</ol>
<p>Also, you can use <code>pkg-config</code> to check if the libs are correctly located.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre>1
</pre></td><td class="code"><pre><span class="variable">$pkg</span><span class="attribute">-config</span> <span class="subst">--</span>libs opencv
</pre></td></tr></table></figure>


<p>The output will look like this:</p>
<pre><code>/usr/<span class="built_in">local</span>/lib/libopencv_calib3d.dylib /usr/<span class="built_in">local</span>/lib/libopencv_contrib.dylib /usr/<span class="built_in">local</span>/lib/libopencv_core.dylib /usr/<span class="built_in">local</span>/lib/libopencv_cuda.dylib /usr/<span class="built_in">local</span>/lib/libopencv_cudaarithm.dylib /usr/<span class="built_in">local</span>/lib/libopencv_cudabgsegm.dylib /usr/<span class="built_in">local</span>/lib/libopencv_cudafeatures2d.dylib /usr/<span class="built_in">local</span>/lib/libopencv_cudafilters.dylib /usr/<span class="built_in">local</span>/lib/libopencv_cudaimgproc.dylib /usr/<span class="built_in">local</span>/lib/libopencv_cudaoptflow.dylib /usr/<span class="built_in">local</span>/lib/libopencv_cudastereo.dylib /usr/<span class="built_in">local</span>/lib/libopencv_cudawarping.dylib /usr/<span class="built_in">local</span>/lib/libopencv_features2d.dylib /usr/<span class="built_in">local</span>/lib/libopencv_flann.dylib /usr/<span class="built_in">local</span>/lib/libopencv_highgui.dylib /usr/<span class="built_in">local</span>/lib/libopencv_imgproc.dylib /usr/<span class="built_in">local</span>/lib/libopencv_legacy.dylib /usr/<span class="built_in">local</span>/lib/libopencv_ml.dylib /usr/<span class="built_in">local</span>/lib/libopencv_nonfree.dylib /usr/<span class="built_in">local</span>/lib/libopencv_objdetect.dylib /usr/<span class="built_in">local</span>/lib/libopencv_optim.dylib /usr/<span class="built_in">local</span>/lib/libopencv_photo.dylib /usr/<span class="built_in">local</span>/lib/libopencv_shape.dylib /usr/<span class="built_in">local</span>/lib/libopencv_softcascade.dylib /usr/<span class="built_in">local</span>/lib/libopencv_stitching.dylib /usr/<span class="built_in">local</span>/lib/libopencv_superres.dylib /usr/<span class="built_in">local</span>/lib/libopencv_ts.<span class="operator">a</span> /usr/<span class="built_in">local</span>/lib/libopencv_video.dylib /usr/<span class="built_in">local</span>/lib/libopencv_videostab.dylib /usr/<span class="built_in">local</span>/lib/libopencv_viz.dylib
</code></pre><h3 id="3-_Reference:">3. Reference:</h3>
<p>[1] <a href="http://code.opencv.org/issues/3582" target="_blank">http://code.opencv.org/issues/3582</a><br>[2] <a href="http://stackoverflow.com/questions/19671827/opencv-installation-on-mac-os-x" target="_blank">http://stackoverflow.com/questions/19671827/opencv-installation-on-mac-os-x</a><br>[3] <a href="http://ibivanchev.blogspot.be/2013/10/opencv-mac-os-x-109.html" target="_blank">http://ibivanchev.blogspot.be/2013/10/opencv-mac-os-x-109.html</a></p>
]]></content>
    
    
      <category term="opencv" scheme="http://hugofeng.info/tags/opencv/"/>
    
  </entry>
  
</feed>
